create or replace procedure DECISIONPOINT_DEV.STAGE.GEN_SCHEDULES_API_PROC(DB VARCHAR, DB_SCHEMA VARCHAR)
returns string
language sql
as
declare  
  select_statement varchar;
  executed_statment varchar;
  res resultset;
begin  
  ------- GEN_SCHEDULES_HISTORY -------
  -- Include new entries
  select_statement := 'MERGE INTO ' || :DB || '.' || :DB_SCHEMA || '.GEN_SCHEDULES_HISTORY TARGET
  USING (
    select PROJECTID, PROJECTNAME, SCHEDULE_ID, SCHEDULE_NAME, DIVISION_ID, DIVISION_NAME, SCHEDULE_DESCRIPTION, SCHEDULE_VERSION, SCHEDULE_DATE_CREATED, SCHEDULE_DATE_MODIFIED, SCHEDULE_STATE, SCHEDULE_START_DATE, SCHEDULE_END_DATE, SCHEDULE_RRULE, SCHEDULE_REFERENCED_TYPE, ROW_HASH, SF_DATETIME_INS from  ' || :DB || '.' || :DB_SCHEMA || '.GEN_SCHEDULES_TMP
  ) STAGE
  ON TARGET.ROW_HASH = STAGE.ROW_HASH  
  -- If it is the same info, keep the old one, otherwise, add a new row
  WHEN MATCHED THEN UPDATE 
    SET
      TARGET.SCHEDULE_CURRENT_RECORD = NULL,
      TARGET.SCHEDULE_SOFT_DELETE = FALSE,
      TARGET.SF_DATETIME_UPD = TARGET.SF_DATETIME_INS
  WHEN NOT MATCHED THEN INSERT 
    (PROJECTID, PROJECTNAME, SCHEDULE_ID, SCHEDULE_NAME, DIVISION_ID, DIVISION_NAME, SCHEDULE_DESCRIPTION, SCHEDULE_VERSION, SCHEDULE_DATE_CREATED, SCHEDULE_DATE_MODIFIED, SCHEDULE_STATE, SCHEDULE_START_DATE, SCHEDULE_END_DATE, SCHEDULE_RRULE, SCHEDULE_REFERENCED_TYPE,  SCHEDULE_START_DATES, SCHEDULE_END_DATES, ROW_HASH, SF_DATETIME_INS, SF_DATETIME_UPD, SCHEDULE_CURRENT_RECORD, SCHEDULE_SOFT_DELETE
    )
    VALUES (
      STAGE.PROJECTID,
      STAGE.PROJECTNAME,
      STAGE.SCHEDULE_ID,
      STAGE.SCHEDULE_NAME,
      STAGE.DIVISION_ID,
      STAGE.DIVISION_NAME,
      STAGE.SCHEDULE_DESCRIPTION,
      STAGE.SCHEDULE_VERSION,
      STAGE.SCHEDULE_DATE_CREATED,
      STAGE.SCHEDULE_DATE_MODIFIED,        
      STAGE.SCHEDULE_STATE,
      STAGE.SCHEDULE_START_DATE,
      STAGE.SCHEDULE_END_DATE,
      STAGE.SCHEDULE_RRULE,
      STAGE.SCHEDULE_REFERENCED_TYPE,
      RRULE_INTERPRETER_UDF(STAGE.SCHEDULE_START_DATE, SCHEDULE_RRULE, TO_VARCHAR(DATEADD(\'YEAR\',1, DATE_TRUNC(\'YEAR\',current_date())),\'YYYYMMDDT000000\')),
      RRULE_INTERPRETER_UDF(STAGE.SCHEDULE_END_DATE, SCHEDULE_RRULE, TO_VARCHAR(DATEADD(\'YEAR\',1, DATE_TRUNC(\'YEAR\',current_date())),\'YYYYMMDDT000000\')),
      STAGE.ROW_HASH,
      STAGE.SF_DATETIME_INS,
      STAGE.SF_DATETIME_INS, -- SF_DATETIME_UPD column
      NULL,
      0
    )';  
 execute immediate :select_statement;
 
 -- Updates current record and upd dt for the records that changed
 select_statement := 'MERGE INTO ' || :DB || '.' || :DB_SCHEMA || '.GEN_SCHEDULES_HISTORY TARGET
  USING (
    select PROJECTID, SCHEDULE_ID, SF_DATETIME_INS from ' || :DB || '.' || :DB_SCHEMA || '.GEN_SCHEDULES_TMP
  ) STAGE
  ON TARGET.PROJECTID = STAGE.PROJECTID
  AND TARGET.SCHEDULE_ID = STAGE.SCHEDULE_ID
  -- If it is the same info, keep the old one, otherwise, add a new row
  WHEN MATCHED AND TARGET.SCHEDULE_CURRENT_RECORD = TRUE THEN UPDATE 
    SET
      TARGET.SCHEDULE_CURRENT_RECORD = FALSE,
      TARGET.SF_DATETIME_UPD = STAGE.SF_DATETIME_INS';
 execute immediate :select_statement;
 
 -- Soft Delete
  select_statement := 'MERGE INTO ' || :DB || '.' || :DB_SCHEMA || '.GEN_SCHEDULES_HISTORY TARGET
  USING (
    select PROJECTID, MAX(SF_DATETIME_INS) AS MAX_SF_DT from ' || :DB || '.' || :DB_SCHEMA || '.GEN_SCHEDULES_TMP GROUP BY 1
  ) STAGE
  ON TARGET.PROJECTID = STAGE.PROJECTID
  -- (any current value true was deleted since the others are null or false based on previous steps)
  WHEN MATCHED AND TARGET.SCHEDULE_CURRENT_RECORD = TRUE THEN UPDATE 
    SET 
 		TARGET.SCHEDULE_SOFT_DELETE = TRUE,
 		TARGET.SCHEDULE_CURRENT_RECORD = TRUE,
 		TARGET.SF_DATETIME_UPD = STAGE.MAX_SF_DT
  -- Update current record
  WHEN MATCHED AND TARGET.SCHEDULE_CURRENT_RECORD IS NULL THEN UPDATE 
    SET 
    	TARGET.SCHEDULE_CURRENT_RECORD = TRUE';
 execute immediate :select_statement;

 ------- GEN_SCHEDULE_GROUPS_HISTORY -------
  -- Include new entries
select_statement := 'MERGE INTO ' || :DB || '.' || :DB_SCHEMA || '.GEN_SCHEDULE_GROUPS_HISTORY TARGET
  USING (
    select PROJECTID, PROJECTNAME, GROUP_ID, GROUP_NAME, DIVISION_ID, DIVISION_NAME, GROUP_DESCRIPTION, GROUP_VERSION, GROUP_DATE_CREATED, GROUP_DATE_MODIFIED, GROUP_STATE, GROUP_TIMEZONE, OPEN_SCHEDULES, CLOSED_SCHEDULES, HOLIDAY_SCHEDULES, EDGE_UPDATE_SCHEDULES, ROW_HASH, SF_DATETIME_INS, VERSION, DATECREATED, DATEMODIFIED, MODIFIEDBY from ' || :DB || '.' || :DB_SCHEMA || '.GEN_SCHEDULE_GROUPS_TMP
  ) STAGE
  ON TARGET.ROW_HASH = STAGE.ROW_HASH  
  -- If it is the same info, keep the old one, otherwise, add a new row
  WHEN MATCHED THEN UPDATE 
    SET
      TARGET.GROUP_CURRENT_RECORD = NULL,
      TARGET.GROUP_SOFT_DELETE = FALSE,
      TARGET.SF_DATETIME_UPD = TARGET.SF_DATETIME_INS
  WHEN NOT MATCHED THEN INSERT 
    (PROJECTID, PROJECTNAME, GROUP_ID, GROUP_NAME, DIVISION_ID, DIVISION_NAME, GROUP_DESCRIPTION, GROUP_VERSION, GROUP_DATE_CREATED, GROUP_DATE_MODIFIED, GROUP_STATE, GROUP_TIMEZONE, OPEN_SCHEDULES, CLOSED_SCHEDULES, HOLIDAY_SCHEDULES, EDGE_UPDATE_SCHEDULES, ROW_HASH, SF_DATETIME_INS, SF_DATETIME_UPD, GROUP_CURRENT_RECORD, GROUP_SOFT_DELETE)
    VALUES (
      STAGE.PROJECTID,
      STAGE.PROJECTNAME,
      STAGE.GROUP_ID,
      STAGE.GROUP_NAME,
      STAGE.DIVISION_ID,
      STAGE.DIVISION_NAME,
      STAGE.GROUP_DESCRIPTION,
      STAGE.GROUP_VERSION,
      STAGE.GROUP_DATE_CREATED,
      STAGE.GROUP_DATE_MODIFIED,        
      STAGE.GROUP_STATE,
      STAGE.GROUP_TIMEZONE,
      STAGE.OPEN_SCHEDULES,
      STAGE.CLOSED_SCHEDULES,
      STAGE.HOLIDAY_SCHEDULES,        
      STAGE.EDGE_UPDATE_SCHEDULES,
      STAGE.ROW_HASH,        
      STAGE.SF_DATETIME_INS,
      STAGE.SF_DATETIME_INS, -- SF_DATETIME_UPD column
      NULL,
      0
    )';
execute immediate :select_statement;

-- Updates current record and upd dt for the records that changed
select_statement := 'MERGE INTO ' || :DB || '.' || :DB_SCHEMA || '.GEN_SCHEDULE_GROUPS_HISTORY TARGET
  USING (
    select PROJECTID, GROUP_ID, SF_DATETIME_INS from ' || :DB || '.' || :DB_SCHEMA || '.GEN_SCHEDULE_GROUPS_TMP
  ) STAGE
  ON TARGET.PROJECTID = STAGE.PROJECTID
  AND TARGET.GROUP_ID = STAGE.GROUP_ID
  -- If it is the same info, keep the old one, otherwise, add a new row
  WHEN MATCHED AND TARGET.GROUP_CURRENT_RECORD = TRUE THEN UPDATE 
    SET
      TARGET.GROUP_CURRENT_RECORD = FALSE,
      TARGET.SF_DATETIME_UPD = STAGE.SF_DATETIME_INS';
execute immediate :select_statement;      

 -- Soft Delete
select_statement := 'MERGE INTO ' || :DB || '.' || :DB_SCHEMA || '.GEN_SCHEDULE_GROUPS_HISTORY TARGET
  USING (
    select PROJECTID, MAX(SF_DATETIME_INS) AS MAX_SF_DT from ' || :DB || '.' || :DB_SCHEMA || '.GEN_SCHEDULE_GROUPS_TMP GROUP BY 1
  ) STAGE
  ON TARGET.PROJECTID = STAGE.PROJECTID  
  -- any current value true was deleted since the others are null or false based on previous steps
  WHEN MATCHED AND TARGET.GROUP_CURRENT_RECORD = TRUE THEN UPDATE
    SET
    	TARGET.GROUP_SOFT_DELETE = TRUE,
 		TARGET.GROUP_CURRENT_RECORD = TRUE,
 		TARGET.SF_DATETIME_UPD = STAGE.MAX_SF_DT
  -- Update current record 
  WHEN MATCHED AND TARGET.GROUP_CURRENT_RECORD IS NULL THEN UPDATE
    SET
    	TARGET.GROUP_CURRENT_RECORD = TRUE';
execute immediate :select_statement; 

execute immediate 'commit';
 
return 'No errors';
 
exception
  when other then
    return object_construct('Error type', 'Other error',
                            'SQL', select_statement,
                            'SQLCODE', sqlcode,
                            'SQLERRM', sqlerrm,
                            'SQLSTATE', sqlstate);
end;