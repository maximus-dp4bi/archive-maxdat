create or replace view STAGE.GEN_SCHEDULES_API_VW AS
WITH GSGH AS
(
SELECT 
    PROJECTID
    ,PROJECTNAME
    ,GROUP_HISTORY_ID
    ,GROUP_ID
    ,GROUP_NAME
    ,GROUP_VERSION
    ,GROUP_DATE_CREATED
    ,GROUP_DATE_MODIFIED
    ,GROUP_STATE
    ,GROUP_TIMEZONE
    ,SCHEDULE_TYPE
    ,SD.VALUE:id AS SCHEDULE_ID
    ,GROUP_CURRENT_RECORD    
    ,GROUP_SOFT_DELETE
FROM
    STAGE.GEN_SCHEDULE_GROUPS_HISTORY
    UNPIVOT(SCHEDULES FOR SCHEDULE_TYPE IN (OPEN_SCHEDULES,CLOSED_SCHEDULES,HOLIDAY_SCHEDULES,EDGE_UPDATE_SCHEDULES))
    ,LATERAL FLATTEN(INPUT=>SCHEDULES,RECURSIVE=>FALSE) SDS
    ,LATERAL FLATTEN(INPUT=>SDS.VALUE,RECURSIVE=>FALSE) SD
)
SELECT
    GSGH.PROJECTID
    ,GSGH.PROJECTNAME
    ,SCHEDULE_HISTORY_ID
    ,GROUP_HISTORY_ID
    ,GROUP_ID
    ,GROUP_NAME    
    ,GSH.SCHEDULE_ID
    ,SCHEDULE_NAME
    ,GROUP_TIMEZONE
    --,SCHEDULE_START_DATE -- Ommited since it is the same value as the first occurence
    --,SCHEDULE_END_DATE -- Ommited since it is the same value as the first occurence    
    ,convert_timezone(GROUP_TIMEZONE,convert_timezone(GROUP_TIMEZONE,'America/Los_Angeles', to_timestamp_ntz(SSDT.VALUE::VARCHAR,'YYYY-MM-DD HH24:MI:SS'))) AS START_DATE
    ,convert_timezone(GROUP_TIMEZONE,convert_timezone(GROUP_TIMEZONE,'America/Los_Angeles', to_timestamp_ntz(SCHEDULE_END_DATES[SSDT.INDEX]::VARCHAR,'YYYY-MM-DD HH24:MI:SS'))) AS END_DATE
    ,convert_timezone('UTC',convert_timezone(GROUP_TIMEZONE,'America/Los_Angeles', to_timestamp_ntz(SSDT.VALUE::VARCHAR,'YYYY-MM-DD HH24:MI:SS'))) AS START_DATE_UTC
    ,convert_timezone('UTC',convert_timezone(GROUP_TIMEZONE,'America/Los_Angeles', to_timestamp_ntz(SCHEDULE_END_DATES[SSDT.INDEX]::VARCHAR,'YYYY-MM-DD HH24:MI:SS'))) AS END_DATE_UTC    
    ,day(START_DATE) AS START_DATE_DAY
    ,dayname(START_DATE) AS START_DATE_DAY_NAME
    ,dayofweek(START_DATE) AS START_DATE_DAY_OF_WEEK
    ,dayofweekiso(START_DATE) AS START_DATE_DAY_OF_WEEK_ISO
    ,dayofyear(START_DATE) AS START_DATE_DAY_OF_YEAR
    ,week(START_DATE) AS START_DATE_WEEK
    ,weekiso(START_DATE) AS START_DATE_WEEK_ISO
    ,weekofyear(START_DATE) AS START_DATE_WEEK_OF_YEAR
    ,month(START_DATE) AS START_DATE_MONTH
    ,monthname(START_DATE) AS START_DATE_MONTH_NAME
    ,quarter(START_DATE) AS START_DATE_QUARTER
    ,year(START_DATE) AS START_DATE_YEAR    
    ,day(END_DATE) AS END_DATE_DAY
    ,dayname(END_DATE) AS END_DATE_DAY_NAME
    ,dayofweek(END_DATE) AS END_DATE_DAY_OF_WEEK
    ,dayofweekiso(END_DATE) AS END_DATE_DAY_OF_WEEK_ISO
    ,dayofyear(END_DATE) AS END_DATE_DAY_OF_YEAR
    ,week(END_DATE) AS END_DATE_WEEK
    ,weekiso(END_DATE) AS END_DATE_WEEK_ISO
    ,weekofyear(END_DATE) AS END_DATE_WEEK_OF_YEAR
    ,month(END_DATE) AS END_DATE_MONTH
    ,monthname(END_DATE) AS END_DATE_MONTH_NAME
    ,quarter(END_DATE) AS END_DATE_QUARTER
    ,year(END_DATE) AS END_DATE_YEAR
    ,case when convert_timezone(GROUP_TIMEZONE, current_timestamp()) > to_timestamp_ntz(SCHEDULE_END_DATES[SSDT.INDEX]::VARCHAR,'YYYY-MM-DD HH24:MI:SS') then TRUE else FALSE end as SCHEDULE_HAS_RECURRED   
    ,case when SCHEDULE_RRULE is not null then TRUE else FALSE end as SCHEDULE_RECURS_CURRENTLY -- need to clarify what information is this    
    ,SCHEDULE_DATE_CREATED
    ,SCHEDULE_DATE_MODIFIED
    ,SCHEDULE_VERSION
    ,SCHEDULE_STATE
    ,SCHEDULE_RRULE
    ,SCHEDULE_SOFT_DELETE
    ,SCHEDULE_CURRENT_RECORD
    ,GROUP_CURRENT_RECORD
    ,SCHEDULE_TYPE -- need to clarify what information is this
FROM 
    GSGH JOIN STAGE.GEN_SCHEDULES_HISTORY GSH ON
    GSGH.PROJECTID = GSH.PROJECTID AND
    GSGH.SCHEDULE_ID = GSH.SCHEDULE_ID
    ,LATERAL FLATTEN(INPUT=>SCHEDULE_START_DATES,RECURSIVE=>FALSE) SSDT    
;