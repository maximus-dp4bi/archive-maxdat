CREATE SCHEMA DECISIONPOINT_UAT.STAGE;                
create or replace TABLE DECISIONPOINT_UAT.STAGE.PI_USER_DETAILS_HISTORY (
	PROJECTID VARCHAR(255),
	PROGRAMID VARCHAR(255),
	INGESTIONDATETIME TIMESTAMP_NTZ(9),
	DEPARTMENT VARCHAR(16777216),
	DIVISIONID VARCHAR(16777216),
	EMAIL VARCHAR(16777216),
	EMPLOYEEID VARCHAR(16777216),
	EMPLOYEETYPE VARCHAR(16777216),
	HIREDATE VARCHAR(16777216),
	USERDETAILSID VARCHAR(16777216),
	MANAGERID VARCHAR(16777216),
	FULLNAME VARCHAR(16777216),
	STATE VARCHAR(16777216),
	STATECHANGEDATE VARCHAR(16777216),
	STATECHANGEREASON VARCHAR(16777216),
	TITLE VARCHAR(16777216),
	RAW VARIANT,
	ROW_HASH NUMBER(19,0),
	SNOWFLAKE_INSERT_DATETIME TIMESTAMP_NTZ(9),
	SNOWFLAKE_UPDATE_DATETIME TIMESTAMP_NTZ(9),
	AS_OF_DATE DATE,
	INSERT_BY VARCHAR(500),
	CURRENT_USER_RECORD NUMBER(1,0)
);                


                
                
CREATE OR REPLACE VIEW DECISIONPOINT_UAT.STAGE.LOAD_PI_USER_HISTORY_VW AS         
SELECT 
PROJECTID
--, PROJECTNAME
, PROGRAMID
--, PROGRAMNAME
, INGESTIONDATETIME,
RAW:department::varchar AS Department,
RAW:divisionId::varchar AS DivisionId,
--RAW:divisionName::varchar AS DivisionName,
RAW:email::varchar AS Email,
Raw:employeeId::varchar AS EmployeeId,
Raw:employeeType::varchar EmployeeType,
Raw:hireDate::varchar HireDate,
Raw:id::varchar AS UserDetailsID,
Raw:managerId::varchar AS ManagerId,
Raw:name::varchar AS FullName,
Raw:state::varchar AS State,
Raw:stateChangeDate::varchar AS StateChangeDate,
Raw:stateChangeReason::varchar StateChangeReason,
Raw:title::varchar AS Title,
Raw,
HASH(Raw) AS ROW_HASH,
SYSDATE() AS SNOWFLAKE_INSERT_DATETIME,
SYSDATE() AS SNOWFLAKE_UPDATE_DATETIME,
CAST(INGESTIONDATETIME AS DATE) AS AS_OF_DATE,
'PI_USER_LOAD' AS INSERT_BY,
1 AS CURRENT_USER_RECORD
FROM PUREINSIGHTS_PRD.RAW.USER_DETAILS; --ORDER BY INGESTIONDATETIME DESC                
                
 ;               
                
CREATE OR REPLACE PROCEDURE DECISIONPOINT_UAT.STAGE.LOAD_PI_USER_HISTORY_PROC(PROJECTID varchar,REINGESTFLAG BOOLEAN,RUNFROMBASHFLAG BOOLEAN
                                                                             ) 
returns varchar not null
language sql
AS
--declare 
declare environment varchar;                
        tempTableName varchar default 'LOAD_PI_USER_HIST_TEMP';
        tgtTableName varchar default 'PI_USER_DETAILS_HISTORY';
        srcTableName varchar default 'LOAD_PI_USER_HISTORY_VW';
        tempTableText varchar;
        mergeInsertUpdate varchar;
        mergeCloseCurrent varchar;
                
BEGIN 
                
SELECT CURRENT_DATABASE() || '.' || CURRENT_SCHEMA() || '.' INTO :environment;
      
tempTableText:= 'CREATE OR REPLACE TEMPORARY TABLE ' || :environment || :tempTableName || ' AS SELECT a.*, b.ROW_HASH TGT_ROW_HASH, b.AS_OF_DATE TGT_AS_OF_DATE FROM ' || :environment || :srcTableName || ' a 
              LEFT JOIN ' || :environment || :tgtTableName || ' b ON a.USERDETAILSID = b.USERDETAILSID AND b.CURRENT_USER_RECORD = 1 
             WHERE (a.ROW_HASH != b.ROW_HASH OR a.AS_OF_DATE = b.AS_OF_DATE OR b.USERDETAILSID IS NULL)' || CASE WHEN TRY_TO_NUMBER(:PROJECTID) IS NULL THEN '' ELSE ' AND a.PROJECTID =' || :PROJECTID END;

mergeInsertUpdate:= 'MERGE INTO ' || :environment || :tgtTableName || ' tgt USING (SELECT * FROM ' || :environment || :tempTableName || ') src ON (tgt.USERDETAILSID = src.USERDETAILSID AND tgt.PROJECTID = src.PROJECTID AND tgt.AS_OF_DATE = src.AS_OF_DATE AND tgt.CURRENT_USER_RECORD = 1) 
                WHEN MATCHED THEN UPDATE
                    SET tgt.PROGRAMID = src.PROGRAMID
                    ,   tgt.INGESTIONDATETIME = src.INGESTIONDATETIME
                    ,   tgt.DEPARTMENT = src.DEPARTMENT
                    ,   tgt.DIVISIONID = tgt.DIVISIONID
                    ,   tgt.EMAIL = src.EMAIL
                    ,   tgt.EMPLOYEEID = src.EMPLOYEEID
                    ,   tgt.EMPLOYEETYPE = src.EMPLOYEETYPE
                    ,   tgt.HIREDATE = src.HIREDATE
                    ,   tgt.MANAGERID = src.MANAGERID
                    ,   tgt.FULLNAME = src.FULLNAME
                    ,   tgt.STATE = src.STATE
                    ,   tgt.STATECHANGEDATE = src.STATECHANGEDATE
                    ,   tgt.STATECHANGEREASON = src.STATECHANGEREASON
                    ,   tgt.TITLE = src.TITLE
                    ,   tgt.RAW = src.RAW
                    ,   tgt.ROW_HASH = src.ROW_HASH
                    ,   tgt.SNOWFLAKE_UPDATE_DATETIME = src.SNOWFLAKE_UPDATE_DATETIME
                WHEN NOT MATCHED AND src.TGT_ROW_HASH != src.ROW_HASH OR src.TGT_ROW_HASH IS NULL THEN INSERT (PROJECTID,
	PROGRAMID,
	INGESTIONDATETIME,
	DEPARTMENT,
	DIVISIONID,
	EMAIL,
	EMPLOYEEID,
	EMPLOYEETYPE,
	HIREDATE,
	USERDETAILSID,
	MANAGERID,
	FULLNAME,
	STATE,
	STATECHANGEDATE,
	STATECHANGEREASON,
	TITLE,
	RAW,
	ROW_HASH,
	SNOWFLAKE_INSERT_DATETIME,
	AS_OF_DATE,
	INSERT_BY,
	CURRENT_USER_RECORD) values(
    src.PROJECTID,
	src.PROGRAMID,
	src.INGESTIONDATETIME,
	src.DEPARTMENT,
	src.DIVISIONID,
	src.EMAIL,
	src.EMPLOYEEID,
	src.EMPLOYEETYPE,
	src.HIREDATE,
	src.USERDETAILSID,
	src.MANAGERID,
	src.FULLNAME,
	src.STATE,
	src.STATECHANGEDATE,
	src.STATECHANGEREASON,
	src.TITLE,
	src.RAW,
	src.ROW_HASH,
	src.SNOWFLAKE_INSERT_DATETIME,
	src.AS_OF_DATE,
	src.INSERT_BY,
	src.CURRENT_USER_RECORD)' ;                


mergeCloseCurrent:= 'MERGE INTO ' || :environment || :tgtTableName || ' tgt USING (SELECT * FROM ' || :environment || :tempTableName || ') src ON (tgt.USERDETAILSID = src.USERDETAILSID AND tgt.PROJECTID = src.PROJECTID AND tgt.CURRENT_USER_RECORD = 1 AND src.TGT_AS_OF_DATE = tgt.AS_OF_DATE)
                WHEN MATCHED AND src.ROW_HASH != src.TGT_ROW_HASH AND src.TGT_ROW_HASH IS NOT NULL THEN UPDATE
                    SET SNOWFLAKE_UPDATE_DATETIME = src.SNOWFLAKE_UPDATE_DATETIME
                    ,   CURRENT_USER_RECORD = 0' ;                                

EXECUTE IMMEDIATE tempTableText;
                
BEGIN TRANSACTION;

EXECUTE IMMEDIATE mergeInsertUpdate;
EXECUTE IMMEDIATE mergeCloseCurrent;
            
COMMIT;              
  RETURN 'Success';--PROJECTID;
EXCEPTION
  WHEN OTHER THEN
  ROLLBACK;
  RETURN 'Error';                
--RETURN mergeInsertUpdate;
END;
                
                
CALL DECISIONPOINT_UAT.STAGE.LOAD_PI_USER_HISTORY_PROC('All',TRUE,TRUE);

CALL DECISIONPOINT_DEV.STAGE.LOAD_PI_USER_HISTORY_PROC('All', TRUE, TRUE);                
                
CREATE OR REPLACE VIEW DECISIONPOINT_UAT.STAGE.PI_USER_DETAILS_DAILY_VW AS(
WITH usr AS (SELECT *, AS_OF_DATE AS START_DATE, 
    CASE WHEN CURRENT_USER_RECORD = 1 THEN CAST('2100-12-31' AS DATE) ELSE LEAD(AS_OF_DATE) OVER (PARTITION BY USERDETAILSID ORDER BY AS_OF_DATE ASC)-1 END END_DATE 
FROM DECISIONPOINT_UAT.STAGE.PI_USER_DETAILS_HISTORY)     

CREATE ROLE DATA_WAREHOUSE_PII_READ;
                
GRANT USAGE ON DATABASE DECISIONPOINT_DEV TO ROLE DATA_WAREHOUSE_PII_READ;
GRANT USAGE ON SCHEMA DECISIONPOINT_DEV.STAGE TO ROLE DATA_WAREHOUSE_PII_READ;
                
GRANT USAGE ON DATABASE DECISIONPOINT_UAT TO ROLE DATA_WAREHOUSE_PII_READ;
GRANT USAGE ON SCHEMA DECISIONPOINT_UAT.STAGE TO ROLE DATA_WAREHOUSE_PII_READ;
                
GRANT SELECT ON TABLE DECISIONPOINT_DEV.STAGE.PI_USER_DETAILS_HISTORY TO ROLE DATA_WAREHOUSE_PII_READ;
GRANT SELECT ON TABLE DECISIONPOINT_UAT.STAGE.PI_USER_DETAILS_HISTORY TO ROLE DATA_WAREHOUSE_PII_READ;
                
GRANT SELECT ON VIEW DECISIONPOINT_DEV.STAGE.PI_USER_DETAILS_DAILY_VW TO ROLE DATA_WAREHOUSE_PII_READ;
GRANT SELECT ON VIEW DECISIONPOINT_UAT.STAGE.PI_USER_DETAILS_DAILY_VW TO ROLE DATA_WAREHOUSE_PII_READ;
                
GRANT ROLE DATA_WAREHOUSE_PII_READ TO USER MALDRICH;